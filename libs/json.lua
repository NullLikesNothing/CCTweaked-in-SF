-- Ripped from `https://cloud-catcher.squiddev.cc/` and minified
local tonumber=tonumber;local function a(b,c,d,e)c=c+#b:match('^%s*',c)if b:sub(c,c)~=d then if e then error('Expected '..d)end;return c,false end;return c+1,true end;local f={b='\b',f='\f',n='\n',r='\r',t='\t'}local function g(b,c)local h,i={},0;if c>#b then error("Malformed JSON (in string)")end;while true do local j=b:sub(c,c)if j=='"'then return table.concat(h,"",1,i),c+1 end;i=i+1;if j=='\\'then local k=b:sub(c+1,c+1)if not k then error("Malformed JSON (in string)")end;if k=="u"then local l=tonumber(b:sub(c+2,c+5),16)if not l then error("Malformed JSON (in unicode string) ")end;if l<=255 then c,h[i]=c+6,string.char(l)else c,h[i]=c+6,"?"end else c,h[i]=c+2,f[k]or k end else c,h[i]=c+1,j end end end;local function m(b,c)local n=b:match('^-?%d+%.?%d*[eE]?[+-]?%d*',c)local o=tonumber(n)if not o then error('Error parsing number at position '..c..'.')end;return o,c+#n end;local p={}local q={['true']=true,['false']=false,['null']=p}local r={}for s=0,255 do local j=string.char(s)if s>=32 and s<=126 then r[j]=j else r[j]=("\\u00%02x"):format(s)end end;r["\t"],r["\n"],r["\r"],r["\""],r["\\"]="\\t","\\n","\\r","\\\"","\\\\"local function t(b,c,u)c=c or 1;if c>#b then error('Reached unexpected end of input.')end;local c=c+#b:match('^%s*',c)local v=b:sub(c,c)if v=='{'then local w,y,z={},true,true;c=c+1;while true do y,c=t(b,c,'}')if y==nil then return w,c end;if not z then error('Comma missing between object items.')end;c=a(b,c,':',true)w[y],c=t(b,c)c,z=a(b,c,',')end elseif v=='['then local A,o,z={},true,true;c=c+1;while true do o,c=t(b,c,']')if o==nil then return A,c end;if not z then error('Comma missing between array items.')end;A[#A+1]=o;c,z=a(b,c,',')end elseif v=='"'then return g(b,c+1)elseif v=='-'or v:match('%d')then return m(b,c)elseif v==u then return nil,c+1 else for B,C in pairs(q)do local D=c+#B-1;if b:sub(c,D)==B then return C,D+1 end end;local E='position '..c..': '..b:sub(c,c+10)error('Invalid json syntax starting at '..E)end end;local F,G,tostring,pairs,next,type,H=string.format,string.gsub,tostring,pairs,next,type,table.concat;local function I(J,h,i)local K=type(J)if K=="table"then local L=type(next(J))if L=="nil"then h[i],i="{}",i+1;return i elseif L=="string"then h[i],i="{",i+1;local v=true;for M,N in pairs(J)do if v then v=false else h[i],i=",",i+1 end;h[i]=F("\"%s\":",M)i=I(N,h,i+1)end;h[i],i="}",i+1;return i elseif L=="number"then h[i],i="[",i+1;for s=1,#J do if s>1 then h[i],i=",",i+1 end;i=I(J[s],h,i)end;h[i],i="]",i+1;return i else error("Cannot serialize key "..L)end elseif K=="string"then if J:match("^[ -~]*$")then h[i],i=G(F("%q",J),"\n","n"),i+1 else h[i],i="\""..G(J,".",r).."\"",i+1 end;return i elseif K=="number"or K=="boolean"then h[i],i=tostring(J),i+1;return i else error("Cannot serialize type "..K)end end;local function O(P)local Q={}local i=I(P,Q,1)return H(Q,"",1,i-1)end;local function R(S)local T,U=pcall(t,S)if T then return U else return nil,U end end;return{stringify=O,try_parse=R,parse=t,null=p}